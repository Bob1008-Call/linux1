（1）	指针和引用的区别
i.	指针声明时可以不赋值；引用声明时必须初始化
ii.	指针++在32为操作系统向后偏移4个字节，引用++是给实体加对应的大小
iii.	Sizeof指针32为操作系统下是4，引用是引用实体的大小
iv.	指针由多级指针，引用没有多级引用
v.	指针可以随时改变指向，引用在初始化后就不能改变了
vi.	有NULL指针，没有NULL引用
vii.	访问实体方式不同，指针式解引用，引用编译器自己处理
viii.	引用比指针更安全
（2）	堆（较灵活）和栈的区别
i.	管理方式：栈由操作系统分配释放， 堆需要程序员释放，容易产生内存泄漏
ii.	空间大小：每个进程拥有栈的大小远远小于堆的大小 64位windows1MB linux：10
iii.	生长方式：堆向上，内存由低到高，栈向下：内存由高到低
iv.	分配方式：堆：动态，没有静态；栈：静态：操作系统完成（局部变量）、动态（alloca，操作系统自动释放）
v.	分配效率：栈：硬件层支持：分配专门的寄存器存放栈的地址，效率高；堆由C/C++提供的库函数、运算符完成，实现机制复杂
vi.	存放内容：栈：函数返回地址、相关参数、局部变量、寄存器、函数调用（断点保存）；堆：一般情况堆顶使用一个字节的空间存放堆的大小、堆中存放的内容手动添加的
vii.	https://blog.csdn.net/C1029323236/article/details/84727063
viii.	还有数据结构中的栈
（3）	new和delete是如何实现的，new 与 malloc的异同处
i.	new大致分为三步
首先调用operator new标准库函数，传入的大小为申请空间大小，返回分配内存空间的起始地址
分配的内存是未初始化的，也是未类型化的，第二步就是对原始内存上类对象进行初始化，调用相应类的构造函数
最后一步就是返回新分配并构造好的对象的指针
ii.	delete实现
调用析构函数
通过operator delete来释放创建对象的内存
iii.	new和malloc的区别
相同点：new和malloc都是从堆上申请空间
不同点：
malloc是函数，new是操作符
new申请的空间可以初始化，malloc申请的空间不能初始化
new申请空间  只需要加上空间的类型，malloc需要传递空间大小
new申请的空间不需要强转，malloc申请的空间需要强转
new申请空间效率低一些，因为底层封装了malloc
new申请空间失败需要捕获异常，malloc失败返回NULL，使用时需要判空
malloc申请自定义类型空间不调用构造函数，new调用构造函数
malloc失败返回0，new失败抛出bad_alloc异常。
malloc申请的空间一定在堆上，new不一定，因为可以重载operator new
将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。
只能建立在堆上：设置析构函数为私有的，但是这样存在一个问题，就是无法解决继承问题，当该类作为基类时，析构函数通常要设为virtual，然后在子类中重写，实现多态，因此不能设为私有，可以用protected，类外无法访问，子类可以访问，还存在一个new开辟，不是delete释放的问题，为了统一，将构造函数也设为protected，提供一个public的static函数完成构造
只能在栈上：只有使用new才会在堆上创建对象，所以将new重载为私有的，就只能在栈上创建对象了。
https://www.cnblogs.com/raichen/p/5808766.html

