虚函数是通过一张虚函数表来实现的，编译器必须要保证虚函数表的指针存在于对象实例中最前面的位置（能保证正确取到虚函数的偏移量），一个带有虚函数的类有一个虚函数表，这个表包含了这个类所有的虚函数的地址，可以把这个表形象的看成一个函数指针数组，每个元素就是虚函数的地址，这时候其实编译器给这个类植入了一个指针，当这个包含虚函数的类实例化对象时，这个指针就会指向这个虚函数表，虚函数表是在定义类的时候初始化，虚函数指针是在构造对象时被初始化。
当我们定义一个Base b，其中b中成员的存放如下：
 ss
虚函数表最后多加了一个节点，这个节点代表后续还有没有虚函数表，当然在不用的操作系统是不一样的，在vs下这个结束标志是NULL，在linux下，如果这个节点为0，表示后续没有虚函数表了，如果为1表示后续还有虚函数表，
class A { virtual Fun(){} };: sizeof(A) = 4(32位机器)/8(64位机器);
虚函数的地址存放在一个虚表里面，一个类有一个虚表，这样计算的大小为指针的大小
class A { static int a; };: sizeof(A) = 1;
static变量对类的大小没有影响
class A { int a; };: sizeof(A) = 4;
class A { static int a; int b; };: sizeof(A) = 4;
（12） 给一个代码，求输出结果
class A
{
public:
A(int x){}
}
问：A a = 1;是否正确, 如果正确, 那么它调用了哪些函数？
因为A类的构造函数没有声明为explicit，所以会发生类型转化，所以该表达式正确
1.	对于没有优化过的编译器，先将1转化为A类型（构造函数），再将1赋值给a（拷贝构造函数）。
2.	对于优化过的编译器，直接用1构造变量a（构造函数）
这类题目更常见的是在基类和子类有不同实现方法。（虚函数相关，栗子很多，不多说了）
（13） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，  ，实现机理，多线程实现等
（14） STL源码中的hash表的实现
闭散列
1.线性探测：哈希函数计算出来的位置如果被占用，则一次向后查找，如果到末尾，就从头开始查询未查找过的。
2.二次探测：如果计算出来的位置为H，该位置被占用，就尝试H+1^2，H+2^2…………
开散列
二次探测其实质式推迟了线性探测的问题，也引来数据独立性
在每一个表格元素中维护一个list：hash function为我们分配一个list，然后插入删除等操作，虽然是在list而进行，但是list够短，搜寻速度还够快
其中表格元素为一个质数表，一共28个常数，大于53，相邻的质数关系是2的倍数中最接近的质数。
（给定一个值，即Hashtable实际需要存储元素的个数）质数表寻找的过程，找大于这个数的最小质数，作为桶的个数

