五、模板
（一）什么是泛型编程：书写一个与类型无关的通用的代码
（二）函数模板
    1.概念
    2.定义格式
        （1）模板的参数列表
            （i）所有的类型参数前必须加唐渝鹏name或者 class 的关键字
            （ii）所有类型的参数必须要用逗号隔开
            （iii）typename和class的区别
            （iiii）注意：类型参数不能使用struct
    3.实例化
        （1）隐式实例化
            （i）没有明确指定模板参数，编译器需要根据实参的类型来推演模板参数T的实际类型
            （ii）注意：一般情况不会进行隐式类型转换
        （2）显式实例化
            （i）明确指定模板参数列表中T的实际类型，
            （ii）不需要进行参数推演
            （iii）会进行隐式的类型转换
                1.转换成功：编译器生成代码
                2.转换失败：编译器报错
    4.调用原理
        （1）对函数模板进行简单的语法检测（实例化之前）
        （2）实例化期间：通过对实参的类型进行推演来确定模板参数列表中的类型参数，根据确定的类型参数的实际类型以及函数模板的实现来生成一份处理具体类型的代码
    5.注意
（三）类模板
（四）非类型的模板参数
    1.template<class T,size_t N>class array;
    2.注意：
        （1）N是类模板中定义的常量
        （2）整型
        （3）double、自定义类型不能作为非类型的模板参数
（五）模板的特化：有些类型让模板处理可能得到一些异常的结果，需要对特殊类型进行特殊处理
    1.函数模板特殊
    2.类模板的特殊
        （1）全特化：将模板参数列表所有的类型参数具体化
        （2）偏特化：
            （i）特化部分参数（从右往左）
            （ii）让模板参数的限制更加严格
（六）模板特化的应用--->类型的萃取
    1.写一个通用的拷贝函数
        （1）memcpy
        （2）for循环+赋值
    2.什么情况使用memcpy，什么情况使用for循环+赋值
        （1）区分T是内置类型还是自定义类型
    3.类型萃取的实现
（七）模板的分离编译
    1.在头文件中声明模板
    2.在源文件中实现模板
    3.在其他文件中实例化模板时 ，编译器就会报错
    4.模板不支持分离编译
        （1）解决方式：模板的实现和定义放在hpp文件
        （2）将模板的定义与声明分开实现，将来在模板的定义文件中对调用的个数进行实例化
